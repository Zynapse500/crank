
use glutin;
use glutin::{GlContext, GlWindow, EventsLoop};

use gl;


/// A window the user can interact with
pub struct Window {
    gl_window: GlWindow,
    events_loop: EventsLoop,

    // Is the window open?
    open: bool
}

/// Frontend for the game to use when modifying the window
pub struct WindowHandle {}


/// The various codes for all the keys on a keyboard
pub use glutin::VirtualKeyCode as KeyCode;

/// Handles events generated by a window
pub trait WindowEventHandler {
    /// Called when the window changes size
    ///
    /// # Arguments
    ///
    /// * 'width' - The new width of the window
    /// * 'height' - The new height of the window
    fn size_changed(&mut self, width: usize, height: usize);


    /// Called when a key is pressed within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was pressed
    fn key_pressed(&mut self, key: KeyCode);

    /// Called when a key is released within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was pressed
    fn key_released(&mut self, key: KeyCode);
}




impl Window {
    /// Creates a new glutin window
    ///
    /// # Arguments
    ///
    /// * 'width' - Width of the window
    /// * 'height' - Height of the window
    /// * 'title' - Title of the window
    pub fn new(width: u32, height: u32, title: &str) -> Result<Self, String> {
        let events_loop = glutin::EventsLoop::new();

        // Window settings
        let window_builder = glutin::WindowBuilder::new()
            .with_dimensions(width, height)
            .with_title(title);

        // OpenGL settings
        let context_builder = glutin::ContextBuilder::new()
            .with_vsync(true);

        // Create window
        let gl_window = match glutin::GlWindow::new(window_builder, context_builder, &events_loop) {
            Err(e) => return Err(format!("{}", e)),

            Ok(window) => window,
        };

        // Load OpenGL
        if let Err(e) = load_gl_context(&gl_window) {
            return Err(format!("{}", e));
        }

        Ok(
            Window {
                gl_window,
                events_loop,

                open: true
            }
        )
    }


    /// Returns a boolean indicating whether the window is open or not
    pub fn is_open(&self) -> bool {
        self.open
    }


    /// Handle events generated by the event loop
    pub fn poll_events(&mut self) {
        let mut window_events = Vec::new();

        self.events_loop.poll_events(|e| {
            match e {
                glutin::Event::WindowEvent {event, ..} => window_events.push(event),

                _ => ()
            }
        });


        for event in window_events {
            use glutin::WindowEvent;
            match event {
                WindowEvent::Closed => self.open = false,
                

                _ => ()
            }
        }
    }


    /// Swap the front and back buffers
    pub fn swap_buffers(&self) -> Result<(), String> {
        if let Err(e) = self.gl_window.swap_buffers() {
            return Err(format!("{}", e));
        }

        Ok(())
    }
}

// Load OpenGL
fn load_gl_context(window: &glutin::GlWindow) -> Result<(), String> {
    // Use the OpenGL context
    unsafe {
        if let Err(e) = window.make_current() {
            return Err(format!("{}", e));
        }
    }

    // Load function pointers
    unsafe {
        gl::load_with(|symbol| { window.get_proc_address(symbol) as *const _ });
        gl::ClearColor(0.0, 1.0, 0.0, 1.0);
    }

    Ok(())
}



impl WindowHandle {
    pub fn new(window: &Window) -> Self {
        WindowHandle {}
    }
}
