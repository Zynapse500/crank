use glutin;
use glutin::{GlContext, GlWindow, EventsLoop, WindowEvent};

use gl;

use std::collections::HashSet;
use std::rc::Rc;
use std::cell::RefCell;

/// A window the user can interact with
pub struct Window {
    pub (self) gl_window: GlWindow,
    pub events_loop: EventsLoop,

    // Is the window open?
    pub (self) open: bool,

    // The current size of the window
    pub (self) size: [u32; 2],


    // Keys that are pressed down
    pressed_keys: HashSet<KeyCode>,

    // Mouse buttons that are pressed down
    pressed_buttons: HashSet<MouseButton>,


    // Position of the cursor
    cursor_position: [i32; 2]
}

/// Frontend for the game to use when modifying the window
pub struct WindowHandle {
    // The window this handler is handling
    parent: Rc<RefCell<Window>>
}


/// The various codes for all the keys on a keyboard
pub use glutin::VirtualKeyCode as KeyCode;

/// The various buttons on the mouse
pub use glutin::MouseButton;


/// Handles events generated by a window
pub trait WindowEventHandler {
    /// Called when the window changes size
    ///
    /// # Arguments
    ///
    /// * 'width' - The new width of the window
    /// * 'height' - The new height of the window
    #[allow(unused_variables)]
    fn size_changed(&mut self, width: u32, height: u32) {}


    /// Called when a key is pressed within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was pressed
    #[allow(unused_variables)]
    fn key_pressed(&mut self, key: KeyCode) {}

    /// Called when a key is released within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was released
    #[allow(unused_variables)]
    fn key_released(&mut self, key: KeyCode) {}


    /// Called when the mouse cursor is moved within the window
    ///
    /// # Arguments
    ///
    /// * 'x' - The new x-position of the cursor
    /// * 'y' - The new y-position of the cursor
    #[allow(unused_variables)]
    fn mouse_moved(&mut self, x: i32, y: i32) {}


    /// Called when a mouse button is pressed within the window
    ///
    /// # Arguments
    ///
    /// * 'button' - The button that was pressed
    /// * 'x' - The x-position of the cursor
    /// * 'y' - The y-position of the cursor
    #[allow(unused_variables)]
    fn mouse_pressed(&mut self, button: MouseButton, x: i32, y: i32) {}


    /// Called when a mouse button is released within the window
    ///
    /// # Arguments
    ///
    /// * 'button' - The button that was released
    /// * 'x' - The x-position of the cursor
    /// * 'y' - The y-position of the cursor
    #[allow(unused_variables)]
    fn mouse_released(&mut self, button: MouseButton, x: i32, y: i32) {}
}


impl Window {
    /// Creates a new glutin window
    ///
    /// # Arguments
    ///
    /// * 'width' - Width of the window
    /// * 'height' - Height of the window
    /// * 'title' - Title of the window
    pub fn new(width: u32, height: u32, title: &str) -> Result<Self, String> {
        let events_loop = glutin::EventsLoop::new();

        // Window settings
        let window_builder = glutin::WindowBuilder::new()
            .with_dimensions(width, height)
            .with_title(title);

        // OpenGL settings
        let context_builder = glutin::ContextBuilder::new()
            .with_vsync(true)
            .with_multisampling(8);

        // Create window
        let gl_window = match glutin::GlWindow::new(window_builder, context_builder, &events_loop) {
            Err(e) => return Err(format!("{}", e)),

            Ok(window) => window,
        };


        // Load OpenGL
        if let Err(e) = Window::load_gl_context(&gl_window) {
            return Err(format!("{}", e));
        }

        Ok(
            Window {
                gl_window,
                events_loop,

                open: true,
                size: [width, height],

                pressed_keys: HashSet::new(),
                pressed_buttons: HashSet::new(),
                cursor_position: [width as i32 / 2, height as i32 / 2]
            }
        )
    }


    // Load OpenGL
    fn load_gl_context(window: &glutin::GlWindow) -> Result<(), String> {
        // Use the OpenGL context
        unsafe {
            if let Err(e) = window.make_current() {
                return Err(format!("{}", e));
            }
        }

        // Load function pointers
        unsafe {
            gl::load_with(|symbol| { window.get_proc_address(symbol) as *const _ });
            gl::ClearColor(0.0, 1.0, 0.0, 1.0);
        }

        Ok(())
    }


    /// Returns a boolean indicating whether the window is open or not
    pub fn is_open(&self) -> bool {
        self.open
    }


    /// Handle events generated by the event loop
    pub fn poll_events(&mut self) -> Vec<WindowEvent> {
        let mut window_events = Vec::new();

        self.events_loop.poll_events(|e| {
            match e {
                glutin::Event::WindowEvent { event, .. } => {
                    window_events.push(event);

                }

                _ => ()
            }
        });

        let mut events = Vec::with_capacity(window_events.len());
        for event in window_events.into_iter() {
            if let Some(event) = self.filter_window_event(event) {
                events.push(event);
            }
        }

        events
    }


    // Removes events that shouldn't be acted upon
    fn filter_window_event(&mut self, event: WindowEvent) -> Option<WindowEvent> {
        use glutin::ElementState;

        match event {
            // Remove repeated key presses
            WindowEvent::KeyboardInput { input, .. } => {
                if let Some(key_code) = input.virtual_keycode {
                    match input.state {
                        ElementState::Pressed => {
                            if !self.pressed_keys.contains(&key_code) {
                                self.pressed_keys.insert(key_code);
                                return Some(event);
                            }
                        }
                        ElementState::Released => {
                            self.pressed_keys.remove(&key_code);
                            return Some(event);
                        }
                    }
                }
            }

            WindowEvent::MouseInput {state, button, ..} => {
                match state {
                    ElementState::Pressed => {
                        self.pressed_buttons.insert(button);
                        return Some(event);
                    }
                    ElementState::Released => {
                        self.pressed_buttons.remove(&button);
                        return Some(event);
                    }
                }
            }

            e => return Some(e)
        }

        None
    }



    /// Swap the front and back buffers
    pub fn swap_buffers(&self) -> Result<(), String> {
        if let Err(e) = self.gl_window.swap_buffers() {
            return Err(format!("{}", e));
        }

        Ok(())
    }


    /// Returns the size of the window
    pub fn get_size(&self) -> Option<(u32, u32)> {
        self.gl_window.get_inner_size()
    }
}


impl WindowHandle {
    pub fn new(parent: Rc<RefCell<Window>>) -> Self {
        WindowHandle {
            parent
        }
    }


    /// Return true if a key is pressed
    pub fn key_down(&self, key: KeyCode) -> bool {
        self.parent.borrow().pressed_keys.contains(&key)
    }


    /// Return true if a mouse button is pressed
    pub fn mouse_down(&self, button: MouseButton) -> bool {
        self.parent.borrow().pressed_buttons.contains(&button)
    }


    /// Returns the current position of the cursor in the window
    pub fn get_cursor_position(&self) -> [i32; 2] {
        self.parent.borrow().cursor_position
    }


    /// Set the title of the window
    pub fn set_title(&mut self, title: &str) {
        self.parent.borrow().gl_window.set_title(title);
    }


    /// Map window coordinates into the range [-1, 1], right and top is positive
    pub fn window_to_ndc(&self, p: [i32; 2]) -> [f32; 2] {
        let size = self.parent.borrow().size;

        let px = p[0] as f32 / size[0] as f32 * 2.0 - 1.0;
        let py = p[1] as f32 / size[1] as f32 * 2.0 - 1.0;

        [px, -py]
    }
}


/// Handle a window event
pub fn handle_window_event<EH: WindowEventHandler>(window: &Rc<RefCell<Window>>, event: WindowEvent, handler: &mut EH) {
    use glutin::ElementState;

    match event {
        // Window
        WindowEvent::Closed => window.borrow_mut().open = false,
        WindowEvent::Resized(w, h) => {
            handler.size_changed(w, h);
            window.borrow_mut().size = [w, h];
        },

        // Keyboard
        WindowEvent::KeyboardInput { input, .. } => {
            if let Some(key_code) = input.virtual_keycode {
                match input.state {
                    ElementState::Pressed => handler.key_pressed(key_code),
                    ElementState::Released => handler.key_released(key_code),
                }
            }
        },

        // Mouse
        WindowEvent::CursorMoved{position:(x, y), ..} => {
            let mx = x.round() as i32;
            let my = y.round() as i32;
            handler.mouse_moved(mx, my);

            window.borrow_mut().cursor_position = [mx, my];
        },
        WindowEvent::MouseInput {state, button, ..} => {
            let cursor = window.borrow().cursor_position;

            match state {
                ElementState::Pressed => handler.mouse_pressed(button, cursor[0], cursor[1]),
                ElementState::Released => handler.mouse_released(button, cursor[0], cursor[1]),
            }
        }

        _ => ()
    }
}
