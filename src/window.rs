
use ::{IntType, Vector2i, FloatType, Vector2};

use glutin;
use glutin::{GlContext, GlWindow, EventsLoop, ControlFlow, Event, WindowEvent, DeviceEvent};


use gl;

use std::collections::HashSet;
use std::rc::Rc;
use std::cell::RefCell;
use std::path::Path;

/// A window the user can interact with
pub struct Window {
    pub(self) gl_window: GlWindow,
    pub events_loop: EventsLoop,

    // Is the window open?
    pub(self) open: bool,

    // The current size of the window
    pub(self) size: [u32; 2],

    // Keys that are pressed down
    pressed_keys: HashSet<KeyCode>,

    // Mouse buttons that are pressed down
    pressed_buttons: HashSet<MouseButton>,

    // Is this window currently focused
    focused: bool,

    // Position of the cursor
    cursor_position: Vector2i,
}

/// Settings for window creation
pub struct WindowSettings {
    pub width: u32,
    pub height: u32,
    pub title: String,

    pub vertical_sync: bool,
}


/// Frontend for the game to use when modifying the window
pub struct WindowHandle {
    // The window this handler is handling
    parent: Rc<RefCell<Window>>
}


/// The various codes for all the keys on a keyboard
pub use glutin::VirtualKeyCode as KeyCode;

/// The various buttons on the mouse
pub use glutin::MouseButton;

/// The mouse wheel scrool delta
pub use glutin::MouseScrollDelta as ScrollDelta;

/// Handles events generated by a window
pub trait WindowEventHandler {
    /// Called when the window changes size
    ///
    /// # Arguments
    ///
    /// * 'width' - The new width of the window
    /// * 'height' - The new height of the window
    #[allow(unused_variables)]
    fn size_changed(&mut self, width: u32, height: u32) {}


    /// Called when a key is pressed within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was pressed
    #[allow(unused_variables)]
    fn key_pressed(&mut self, key: KeyCode) {}

    /// Called when a key is released within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was released
    #[allow(unused_variables)]
    fn key_released(&mut self, key: KeyCode) {}


    /// Called when the mouse cursor is moved within the window
    ///
    /// # Arguments
    ///
    /// * 'x' - The new x-position of the cursor
    /// * 'y' - The new y-position of the cursor
    #[allow(unused_variables)]
    fn mouse_moved(&mut self, x: IntType, y: IntType) {}

    /// Called when a mouse button is pressed within the window
    ///
    /// # Arguments
    ///
    /// * 'button' - The button that was pressed
    /// * 'x' - The x-position of the cursor
    /// * 'y' - The y-position of the cursor
    #[allow(unused_variables)]
    fn mouse_pressed(&mut self, button: MouseButton, x: IntType, y: IntType) {}

    /// Called when a mouse button is released within the window
    ///
    /// # Arguments
    ///
    /// * 'button' - The button that was released
    /// * 'x' - The x-position of the cursor
    /// * 'y' - The y-position of the cursor
    #[allow(unused_variables)]
    fn mouse_released(&mut self, button: MouseButton, x: IntType, y: IntType) {}

    /// Called when the mouse's wheel is moved or a touchpad is scrolling
    ///
    /// # Arguments
    ///
    /// * 'button' - The button that was released
    /// * 'delta' - Describes the magnitude of the scrolling
    #[allow(unused_variables)]
    fn mouse_scrolled(&mut self, delta: ScrollDelta) {}
}


/// Handles file related events generated by a window.
pub trait WindowFileHandler {
    /// Called when a file is dropped into the window
    ///
    /// # Arguments
    ///
    /// * 'path' - Path to the dropped file
    #[allow(unused_variables)]
    fn file_dropped(&mut self, path: &Path) {}


    /// Called when a file is hovering above the window
    ///
    /// # Arguments
    ///
    /// * 'path' - Path to the hovering file
    #[allow(unused_variables)]
    fn file_hovering(&mut self, path: &Path) {}


    /// Called when a hovering file is dragged outsude the window
    ///
    /// # Arguments
    ///
    /// * 'path' - Path to the hovering file
    #[allow(unused_variables)]
    fn file_hover_cancelled(&mut self) {}
}


impl Window {
    /// Creates a new glutin window
    ///
    /// # Arguments
    ///
    /// * 'settings' - Settings for the window
    pub fn new(settings: WindowSettings) -> Result<Self, String> {
        let events_loop = glutin::EventsLoop::new();

        // Window settings
        let window_builder = glutin::WindowBuilder::new()
            .with_dimensions(settings.width, settings.height)
            .with_title(settings.title);

        // OpenGL settings
        let context_builder = glutin::ContextBuilder::new()
            .with_vsync(settings.vertical_sync)
            .with_multisampling(8);

        // Create window
        let gl_window = match glutin::GlWindow::new(window_builder, context_builder, &events_loop) {
            Err(e) => return Err(format!("{}", e)),

            Ok(window) => window,
        };


        // Load OpenGL
        if let Err(e) = Window::load_gl_context(&gl_window) {
            return Err(format!("{}", e));
        }

        Ok(
            Window {
                gl_window,
                events_loop,

                open: true,
                size: [settings.width, settings.height],

                pressed_keys: HashSet::new(),
                pressed_buttons: HashSet::new(),
                focused: false,

                cursor_position: [settings.width as IntType / 2, settings.height as IntType / 2].into(),
            }
        )
    }


    // Load OpenGL
    fn load_gl_context(window: &glutin::GlWindow) -> Result<(), String> {
        // Use the OpenGL context
        unsafe {
            if let Err(e) = window.make_current() {
                return Err(format!("{}", e));
            }
        }

        // Load function pointers
        unsafe {
            gl::load_with(|symbol| { window.get_proc_address(symbol) as *const _ });
            gl::ClearColor(0.0, 1.0, 0.0, 1.0);
        }

        Ok(())
    }


    /// Returns a boolean indicating whether the window is open or not
    pub fn is_open(&self) -> bool {
        self.open
    }


    /// Handle events generated by the event loop
    pub fn poll_events(&mut self) -> Vec<Event> {
        let mut events = Vec::new();

        self.events_loop.poll_events(|event| {
            events.push(event);
        });

        let mut filtered_events = Vec::with_capacity(events.len());

        for event in events.into_iter() {
            if let Some(event) = self.filter_event(event) {
                filtered_events.push(event);
            }
        }

        filtered_events
    }


    // Removes events that shouldn't be acted upon
    fn filter_event(&mut self, event: Event) -> Option<Event> {

        match event {
            Event::WindowEvent { event, window_id } => {
                if let Some(window_event) = self.filter_window_event(event) {
                    Some(
                        Event::WindowEvent {
                            window_id,
                            event: window_event,
                        }
                    )
                } else {
                    None
                }
            }

            Event::DeviceEvent { event, device_id } => {
                if let Some(device_event) = self.filter_device_event(event) {
                    Some(
                        Event::DeviceEvent {
                            device_id,
                            event: device_event,
                        }
                    )
                } else {
                    None
                }
            }
            _ => None
        }
    }

    // Removes window events that shouldn't be acted upon
    fn filter_window_event(&mut self, event: WindowEvent) -> Option<WindowEvent> {
        use glutin::ElementState;
        match event {
            // Remove repeated key presses
            WindowEvent::KeyboardInput{input, ..} => {
                if let Some(key_code) = input.virtual_keycode {
                    match input.state {
                        ElementState::Pressed => {
                            if !self.pressed_keys.contains(&key_code) {
                                self.pressed_keys.insert(key_code);
                                return Some(event);
                            }
                        }
                        ElementState::Released => {
                            self.pressed_keys.remove(&key_code);
                            return Some(event);
                        }
                    }
                }
            }


            // Save pressed buttons
            WindowEvent::MouseInput { state, button, .. } => {
                match state {
                    ElementState::Pressed => {
                        self.pressed_buttons.insert(button);
                        return Some(event);
                    }
                    ElementState::Released => {
                        self.pressed_buttons.remove(&button);
                        return Some(event);
                    }
                }
            }

            // If the window is (un)focused
            WindowEvent::Focused(focus) => {
                self.focused = focus;
                return Some(event);
            },

            e => return Some(e)
        }

        None
    }


    // Removes device events that shouldn't be acted upon
    fn filter_device_event(&mut self, event: DeviceEvent) -> Option<DeviceEvent> {
        match event {
            e => return Some(e)
        }
    }


    /// Returns list of all events.
    /// If none are available, blocks this thread until one is.
    pub fn wait_events(&mut self) -> Vec<WindowEvent>
    {
        let mut window_event = None;

        self.events_loop.run_forever(|e| {
            match e {
                glutin::Event::WindowEvent { event, .. } => {
                    window_event = Some(event);
                    ControlFlow::Break
                }

                _ => ControlFlow::Continue
            }
        });

        window_event = self.filter_window_event(window_event.unwrap());

        let mut window_events = Vec::new();

        if let Some(event) = window_event {
            window_events.push(event);
        }

        for event in self.poll_events().into_iter() {
            match event {
                Event::WindowEvent {event, ..} => {
                    window_events.push(event);
                }

                _ => ()
            }
        }

        window_events
    }


    /// Swap the front and back buffers
    pub fn swap_buffers(&self) -> Result<(), String> {
        if let Err(e) = self.gl_window.swap_buffers() {
            return Err(format!("{}", e));
        }

        Ok(())
    }


    /// Returns the size of the window
    pub fn get_size(&self) -> Option<(u32, u32)> {
        self.gl_window.get_inner_size()
    }

    /// Get the id of the window
    pub fn id(&self) -> glutin::WindowId {
        self.gl_window.id()
    }
}


impl WindowHandle {
    pub fn new(parent: Rc<RefCell<Window>>) -> Self {
        WindowHandle {
            parent
        }
    }


    /// Return true if a key is pressed
    pub fn key_down(&self, key: KeyCode) -> bool {
        self.parent.borrow().pressed_keys.contains(&key)
    }


    /// Return true if a mouse button is pressed
    pub fn mouse_down(&self, button: MouseButton) -> bool {
        self.parent.borrow().pressed_buttons.contains(&button)
    }


    /// Returns the current position of the cursor in the window
    pub fn get_cursor_position(&self) -> Vector2i {
        self.parent.borrow().cursor_position
    }


    /// Returns the size of the window
    pub fn get_size(&self) -> [u32; 2] {
        self.parent.borrow().size
    }

    /// Returns the width of the window
    pub fn get_width(&self) -> u32 {
        self.parent.borrow().size[0]
    }

    /// Returns the height of the window
    pub fn get_height(&self) -> u32 {
        self.parent.borrow().size[1]
    }


    /// Set the title of the window
    pub fn set_title(&mut self, title: &str) {
        self.parent.borrow().gl_window.set_title(title);
    }


    /// Map window coordinates into the range [-1, 1] (right and top are positive)
    pub fn window_to_ndc(&self, p: Vector2i) -> Vector2 {
        let size = self.parent.borrow().size;

        let px = p[0] as FloatType / size[0] as FloatType * 2.0 - 1.0;
        let py = p[1] as FloatType / size[1] as FloatType * 2.0 - 1.0;

        [px, -py].into()
    }
}


/// Handle a window event
pub fn handle_event<EH: WindowEventHandler>(window: &Rc<RefCell<Window>>, event: Event, handler: &mut EH) {
    use glutin::ElementState;

    match event {
        Event::WindowEvent { event, .. } => {
            match event {
                WindowEvent::Closed => window.borrow_mut().open = false,
                WindowEvent::Resized(w, h) => {
                    window.borrow_mut().size = [w, h];
                    handler.size_changed(w, h);
                }

                // Keyboard
                WindowEvent::KeyboardInput { input, .. } => {
                    if let Some(key_code) = input.virtual_keycode {
                        match input.state {
                            ElementState::Pressed => handler.key_pressed(key_code),
                            ElementState::Released => handler.key_released(key_code),
                        }
                    }
                }

                // Mouse
                WindowEvent::CursorMoved { position: (x, y), .. } => {
                    let mx = x.round() as IntType;
                    let my = y.round() as IntType;
                    handler.mouse_moved(mx, my);

                    window.borrow_mut().cursor_position = [mx, my].into();
                }
                WindowEvent::MouseInput { state, button, .. } => {
                    let cursor = window.borrow().cursor_position;

                    match state {
                        ElementState::Pressed => handler.mouse_pressed(button, cursor[0], cursor[1]),
                        ElementState::Released => handler.mouse_released(button, cursor[0], cursor[1]),
                    }
                }

                WindowEvent::MouseWheel { delta, .. } => {
                    handler.mouse_scrolled(delta);
                }

                // Release all buttons if cursor leaves window
                /*WindowEvent::CursorLeft {..} => {
                    let cursor = window.borrow().cursor_position;
                    for button in window.borrow().pressed_buttons.iter() {
                        handler.mouse_released(button.clone(), cursor[0], cursor[1]);
                    }
                    window.borrow_mut().pressed_buttons.clear();
                }*/

                _ => ()
            }
        }

        Event::DeviceEvent { event, .. } => {
            match event {
                _ => ()
            }
        }

        _ => ()
    }
}


/// Handle a window file event
pub fn handle_window_file_event<FH: WindowFileHandler>(event: Event, handler: &mut FH) {
    match event {
        Event::WindowEvent {event, ..} => {
            match event {
                WindowEvent::DroppedFile(path) => handler.file_dropped(path.as_path()),
                WindowEvent::HoveredFile(path) => handler.file_hovering(path.as_path()),
                WindowEvent::HoveredFileCancelled => handler.file_hover_cancelled(),
                _ => ()
            }
        }

        _ => ()
    }
}

