use glutin;
use glutin::{GlContext, GlWindow, EventsLoop, WindowEvent};

use gl;

use std::collections::HashSet;
use std::rc::Rc;
use std::cell::RefCell;

/// A window the user can interact with
pub struct Window {
    gl_window: GlWindow,
    events_loop: EventsLoop,

    // Is the window open?
    pub (self) open: bool,

    // Keys that are pressed down
    pressed_keys: HashSet<KeyCode>
}

/// Frontend for the game to use when modifying the window
pub struct WindowHandle {
    // The window this handler is handling
    parent: Rc<RefCell<Window>>
}


/// The various codes for all the keys on a keyboard
pub use glutin::VirtualKeyCode as KeyCode;

/// Handles events generated by a window
pub trait WindowEventHandler {
    /// Called when the window changes size
    ///
    /// # Arguments
    ///
    /// * 'width' - The new width of the window
    /// * 'height' - The new height of the window
    fn size_changed(&mut self, width: u32, height: u32);


    /// Called when a key is pressed within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was pressed
    fn key_pressed(&mut self, key: KeyCode);

    /// Called when a key is released within the window
    ///
    /// # Arguments
    ///
    /// * 'key' - The key that was pressed
    fn key_released(&mut self, key: KeyCode);


    /// Called when the mouse cursor is moved within the window
    ///
    /// # Arguments
    ///
    /// * 'x' - The new x-position of the cursor
    /// * 'y' - The new y-position of the cursor
    fn mouse_moved(&mut self, x: i32, y: i32);
}


impl Window {
    /// Creates a new glutin window
    ///
    /// # Arguments
    ///
    /// * 'width' - Width of the window
    /// * 'height' - Height of the window
    /// * 'title' - Title of the window
    pub fn new(width: u32, height: u32, title: &str) -> Result<Self, String> {
        let events_loop = glutin::EventsLoop::new();

        // Window settings
        let window_builder = glutin::WindowBuilder::new()
            .with_dimensions(width, height)
            .with_title(title);

        // OpenGL settings
        let context_builder = glutin::ContextBuilder::new()
            .with_vsync(false)
            .with_multisampling(8);

        // Create window
        let gl_window = match glutin::GlWindow::new(window_builder, context_builder, &events_loop) {
            Err(e) => return Err(format!("{}", e)),

            Ok(window) => window,
        };

        // Load OpenGL
        if let Err(e) = Window::load_gl_context(&gl_window) {
            return Err(format!("{}", e));
        }

        Ok(
            Window {
                gl_window,
                events_loop,

                open: true,
                pressed_keys: HashSet::new()
            }
        )
    }


    // Load OpenGL
    fn load_gl_context(window: &glutin::GlWindow) -> Result<(), String> {
        // Use the OpenGL context
        unsafe {
            if let Err(e) = window.make_current() {
                return Err(format!("{}", e));
            }
        }

        // Load function pointers
        unsafe {
            gl::load_with(|symbol| { window.get_proc_address(symbol) as *const _ });
            gl::ClearColor(0.0, 1.0, 0.0, 1.0);
        }

        Ok(())
    }


    /// Returns a boolean indicating whether the window is open or not
    pub fn is_open(&self) -> bool {
        self.open
    }


    /// Handle events generated by the event loop
    pub fn poll_events(&mut self) -> Vec<WindowEvent> {
        let mut window_events = Vec::new();

        self.events_loop.poll_events(|e| {
            match e {
                glutin::Event::WindowEvent { event, .. } => {
                    window_events.push(event);

                }

                _ => ()
            }
        });

        let mut events = Vec::with_capacity(window_events.len());
        for event in window_events.into_iter() {
            if let Some(event) = self.filter_window_event(event) {
                events.push(event);
            }
        }

        events
    }


    // Removes events that shouldn't be acted upon
    fn filter_window_event(&mut self, event: WindowEvent) -> Option<WindowEvent> {
        use glutin::ElementState;

        match event {
            // Remove repeated key presses
            WindowEvent::KeyboardInput { input, .. } => {
                if let Some(key_code) = input.virtual_keycode {
                    match input.state {
                        ElementState::Pressed => {
                            if !self.pressed_keys.contains(&key_code) {
                                self.pressed_keys.insert(key_code);
                                return Some(event);
                            }
                        }
                        ElementState::Released => {
                            self.pressed_keys.remove(&key_code);
                            return Some(event);
                        }
                    }
                }
            }

            e => return Some(e)
        }

        None
    }



    /// Swap the front and back buffers
    pub fn swap_buffers(&self) -> Result<(), String> {
        if let Err(e) = self.gl_window.swap_buffers() {
            return Err(format!("{}", e));
        }

        Ok(())
    }


    /// Returns the size of the window
    pub fn get_size(&self) -> Option<(u32, u32)> {
        self.gl_window.get_inner_size()
    }
}


impl WindowHandle {
    pub fn new(parent: Rc<RefCell<Window>>) -> Self {
        WindowHandle {
            parent
        }
    }


    /// Return true if a key is pressed
    pub fn key_down(&self, key: KeyCode) -> bool {
        self.parent.borrow().pressed_keys.contains(&key)
    }
}


/// Handle a window event
pub fn handle_window_event<EH: WindowEventHandler>(window: &Rc<RefCell<Window>>, event: WindowEvent, handler: &mut EH) {
    use glutin::ElementState;

    match event {
        // Window
        WindowEvent::Closed => window.borrow_mut().open = false,
        WindowEvent::Resized(w, h) => handler.size_changed(w, h),

        // Keyboard
        WindowEvent::KeyboardInput { input, .. } => {
            if let Some(key_code) = input.virtual_keycode {
                match input.state {
                    ElementState::Pressed => handler.key_pressed(key_code),
                    ElementState::Released => handler.key_released(key_code),
                }
            }
        },

        // Mouse
        WindowEvent::CursorMoved{position:(x, y), ..} => handler.mouse_moved(x.round() as i32, y.round() as i32),

        _ => ()
    }
}